<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeyVert - Nostr Key Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <style>
        :root {
            --bg-primary: #1a1b26;
            --bg-secondary: #24283b;
            --text-primary: #a9b1d6;
            --text-secondary: #7aa2f7;
            --accent: #bb9af7;
            --success: #9ece6a;
            --error: #f7768e;
            --card-bg: #1f2335;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        @media (min-width: 768px) {
            .container {
                grid-template-columns: 1fr 1fr;
            }
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1, h2 {
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        input {
            width: 100%;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
            border: none;
            border-radius: 0.5rem;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1rem;
        }

        button {
            background-color: var(--accent);
            color: var(--bg-primary);
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
        }

        .copy-btn {
            background-color: var(--text-secondary);
            margin-left: 0.5rem;
            padding: 0.5rem 1rem;
        }

        .result-container {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--bg-secondary);
            border-radius: 0.5rem;
        }

        .address-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .address-text {
            flex-grow: 1;
            word-break: break-all;
        }

        .qr-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .qr-code {
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            width: fit-content;
        }

        .error {
            color: var(--error);
            margin-bottom: 1rem;
        }

        .github-link {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            color: var(--text-secondary);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .github-link:hover {
            color: var(--accent);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>KeyVert - Nostr Key Converter</h1>
            <input type="text" id="nostrKey" placeholder="Enter npub or nsec key" onkeypress="if(event.key === 'Enter') convertKey()">
            <button onclick="convertKey()">Convert</button>
            <div id="error" class="error"></div>
            <div id="results" style="display: none;">
                <div class="result-container">
                    <h2>Legacy Address</h2>
                    <div class="address-container">
                        <span id="legacyAddress" class="address-text"></span>
                        <button class="copy-btn" onclick="copyToClipboard('legacyAddress')">Copy</button>
                    </div>
                    <div id="legacyQR" class="qr-code"></div>
                </div>
                <div class="result-container">
                    <h2>SegWit Address</h2>
                    <div class="address-container">
                        <span id="segwitAddress" class="address-text"></span>
                        <button class="copy-btn" onclick="copyToClipboard('segwitAddress')">Copy</button>
                    </div>
                    <div id="segwitQR" class="qr-code"></div>
                </div>
            </div>
        </div>
    </div>

    <a href="https://github.com/satoshipuzzles/keyvert" class="github-link" target="_blank">
        View on GitHub
        <svg height="24" width="24" viewBox="0 0 16 16" version="1.1" fill="currentColor">
            <path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path>
        </svg>
    </a>

    <script>
        // Bech32 implementation
        const CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
        const GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];

        function polymod(values) {
            let chk = 1;
            for (let p = 0; p < values.length; ++p) {
                const top = chk >> 25;
                chk = (chk & 0x1ffffff) << 5 ^ values[p];
                for (let i = 0; i < 5; ++i) {
                    if ((top >> i) & 1) {
                        chk ^= GENERATOR[i];
                    }
                }
            }
            return chk;
        }

        function hrpExpand(hrp) {
            const ret = [];
            for (let i = 0; i < hrp.length; ++i) {
                ret.push(hrp.charCodeAt(i) >> 5);
            }
            ret.push(0);
            for (let i = 0; i < hrp.length; ++i) {
                ret.push(hrp.charCodeAt(i) & 31);
            }
            return ret;
        }

        function verifyChecksum(hrp, data) {
            return polymod(hrpExpand(hrp).concat(data)) === 1;
        }

        function createChecksum(hrp, data) {
            const values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);
            const mod = polymod(values) ^ 1;
            const ret = [];
            for (let p = 0; p < 6; ++p) {
                ret.push((mod >> 5 * (5 - p)) & 31);
            }
            return ret;
        }

        const bech32 = {
            decode(str) {
                if (str.length < 8) {
                    throw new Error("Input too short");
                }
                if (str.length > 90) {
                    throw new Error("Input too long");
                }
                
                const lowered = str.toLowerCase();
                const uppered = str.toUpperCase();
                if (str !== lowered && str !== uppered) {
                    throw new Error("Mixed case string");
                }
                str = lowered;
                
                const split = str.lastIndexOf('1');
                if (split === -1) {
                    throw new Error("No separator character");
                }
                if (split === 0) {
                    throw new Error("Missing HRP");
                }
                
                const hrp = str.substring(0, split);
                const data = [];
                for (let i = split + 1; i < str.length; i++) {
                    const d = CHARSET.indexOf(str.charAt(i));
                    if (d === -1) {
                        throw new Error("Invalid character " + str.charAt(i));
                    }
                    data.push(d);
                }
                
                if (!verifyChecksum(hrp, data)) {
                    throw new Error("Invalid checksum");
                }
                
                return {
                    prefix: hrp,
                    words: data.slice(0, -6)
                };
            },

            fromWords(words) {
                const res = [];
                let bits = 0;
                let value = 0;
                
                for (let i = 0; i < words.length; i++) {
                    value = (value << 5) | words[i];
                    bits += 5;
                    
                    while (bits >= 8) {
                        bits -= 8;
                        res.push((value >> bits) & 0xff);
                    }
                }
                
                return new Uint8Array(res);
            }
        };

        // Base58 implementation
        const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        const base58 = {
            encode(buffer) {
                if (buffer.length === 0) return '';
                
                let digits = [0];
                for (let i = 0; i < buffer.length; i++) {
                    let carry = buffer[i];
                    for (let j = 0; j < digits.length; j++) {
                        carry += digits[j] << 8;
                        digits[j] = carry % 58;
                        carry = (carry / 58) | 0;
                    }
                    
                    while (carry > 0) {
                        digits.push(carry % 58);
                        carry = (carry / 58) | 0;
                    }
                }
                
                let string = '';
                for (let i = digits.length - 1; i >= 0; i--) {
                    string += ALPHABET[digits[i]];
                }
                
                return string;
            }
        };

        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < bytes.length; i++) {
                bytes[i] = parseInt(hex.substr(i * 2, 2), 16);
            }
            return bytes;
        }

        function bytesToHex(bytes) {
            return Array.from(bytes)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
        }

        function npubToHex(npub) {
            try {
                const { prefix, words } = bech32.decode(npub);
                if (prefix !== 'npub') {
                    throw new Error('Invalid npub prefix');
                }
                const bytes = bech32.fromWords(words);
                return bytesToHex(bytes);
            } catch (error) {
                throw new Error('Invalid npub format: ' + error.message);
            }
        }

        function pubkeyToLegacyAddress(pubkeyHex) {
            // Convert hex pubkey to bytes
            const pubkeyBytes = hexToBytes(pubkeyHex);
            
            // SHA256
            const sha256 = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(pubkeyBytes));
            
            // RIPEMD160
            const ripemd160 = CryptoJS.RIPEMD160(sha256);
            
            // Add version byte (0x00 for mainnet)
            const versionedHash = new Uint8Array([0, ...hexToBytes(ripemd160.toString())]);
            
            // Double SHA256 for checksum
            const checksum = CryptoJS.SHA256(CryptoJS.SHA256(CryptoJS.lib.WordArray.create(versionedHash)));
            const checksumBytes = hexToBytes(checksum.toString()).slice(0, 4);
            
            // Combine everything
            const binaryAddr = new Uint8Array([...versionedHash, ...checksumBytes]);
            
            // Base58 encode
            return base58.encode(binaryAddr);
        }

        function pubkeyToSegwitAddress(pubkeyHex) {
            // Convert hex pubkey to bytes
            const pubkeyBytes = hexToBytes(pubkeyHex);
            
            // SHA256
            const sha256 = CryptoJS.SHA256(CryptoJS.lib.WordArray.create(pubkeyBytes));
            
            // RIPEMD160
            const ripemd160 = CryptoJS.RIPEMD160(sha256);
            const program = hexToBytes(ripemd160.toString());
            
            // Convert to 5-bit words
            const words = [];
            for (let i = 0; i < program.length; ++i) {
                for (let j = 0; j < 8; ++j) {
                    words.push((program[i] >> (7 - j)) & 1);
                }
            }
            
            // Group into 5-bit words
            const grouped = [];
            for (let i = 0; i < words.length; i += 5) {
                let value = 0;
                for (let j = 0; j < 5; ++j) {
                    if (i + j < words.length) {
                        value = (value << 1) | words[i + j];
                    }
                }
                grouped.push(value);
            }
            
            // Create checksum
            const checksum = createChecksum('bc', grouped);
            
            // Combine everything
            return 'bc1' + [...grouped, ...checksum].map(i => CHARSET[i]).join('');
        }

        function convertKey() {
            const input = document.getElementById('nostrKey').value.trim();
            const errorDiv = document.getElementById('error');
            const resultsDiv = document.getElementById('results');
            
            try {
                // Convert npub to hex pubkey
                const pubkeyHex = npubToHex(input);
                
                // Generate addresses
                const legacyAddress = pubkeyToLegacyAddress(pubkeyHex);
                const segwitAddress = pubkeyToSegwitAddress(pubkeyHex);
                
                // Update UI
                document.getElementById('legacyAddress').textContent = legacyAddress;
                document.getElementById('segwitAddress').textContent = segwitAddress;
                
                // Generate QR codes
                document.getElementById('legacyQR').innerHTML = '';
                document.getElementById('segwitQR').innerHTML = '';
                
                new QRCode(document.getElementById('legacyQR'), {
                    text: legacyAddress,
                    width: 128,
                    height: 128
                });
                
                new QRCode(document.getElementById('segwitQR'), {
                    text: segwitAddress,
                    width: 128,
                    height: 128
                });
                
                // Show results
                errorDiv.textContent = '';
                resultsDiv.style.display = 'block';
                
            } catch (error) {
                errorDiv.textContent = error.message;
                resultsDiv.style.display = 'none';
            }
        }

        async function copyToClipboard(elementId) {
            const text = document.getElementById(elementId).textContent;
            try {
                await navigator.clipboard.writeText(text);
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            } catch (err) {
                console.error('Failed to copy text: ', err);
            }
        }

        // Add Enter key support for input
        document.getElementById('nostrKey').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                convertKey();
            }
        });
    </script>
</body>
</html> 